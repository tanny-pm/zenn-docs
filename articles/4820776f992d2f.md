---
title: "「Clean Architectures in Python」を読み解いてクリーンアーキテクチャを具体的に理解する"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [python]
published: false
---

# はじめに

# 作るもの

# ドメイン

まずはドメインモデルの定義から始めます。物件情報を表す`Room`データクラスを定義します。このクラスは以下の属性を持ちます。

- UUID
- 部屋のサイズ(平方メートル)
- 賃料（ユーロ/日）
- 経緯度

`dataclass`を活用して、以下のように`Room`クラスを実装します。

```py:rentomatic/domain/room.py
import dataclasses
import uuid


@dataclasses.dataclass
class Room:
    code: uuid.UUID
    size: int
    price: int
    longitude: float
    latitude: float

    @classmethod
    def from_dict(cls, d):
        return cls(**d)

    def to_dict(self):
        return dataclasses.asdict(self)
```

データの操作を簡単にするために、ディクショナリと相互に変換するためのメソッドも定義しています。

このクラスはアプリのエンティティ（実体）として、アプリ全体で参照します。

# リポジトリ

次に、`Room`クラスのデータを含み、データへのアクセスを可能にするクラスを作成します。

書籍ではこれを「リポジトリ」と呼んでいます。Git のリポジトリとは関係がありません。意味通りに、データの「収納庫」のようなものだと理解しておくと良いと思います。

## リポジトリのインターフェース

まずはリポジトリのインターフェースを定義します。（書籍では実装していませんが、わかりやすさのために追加しました）

Python では言語機能としてのインターフェースは存在しませんが、インターフェース的な機能を標準ライブラリの`abc`を利用して実現できます。

`Room`を扱うリポジトリを以下のように定義します。`Room`の一覧を取得する`list()`メソッドと`add()`メソッドを持っています。（書籍では`list()`だけ実装していますが、シンプルすぎるため`add()`を追加）

```py:rentomatic/repository/iroomrepo.py
import abc

from rentomatic.domain.room import Room


class IRoomRepo(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def list(self) -> list[Room]:
        """Get list of all Rooms"""
        pass

    @abc.abstractmethod
    def add(self, room: Room) -> int:
        """Add a new Room"""
        pass
```

## リポジトリの実装（インメモリ）

つぎに、`IRoomRepo`を継承したクラスを実装します。これがリポジトリの実体になります。

リポジトリの機能を実現するためには、`Room`のデータを保持するためのストレージシステムが必要となります。これはテキストファイルでもデータベースでも、なんでも OK です。

ここでは実装をシンプルにするために、ソースコード上に直接記載されたディクショナリを扱う、メモリ内ストレージシステム（`MemRepo`）を実装します。（この記事の後半ではデータベースを利用する例を紹介します。）

先ほど作成した`IRoomRepo`を継承した`MemRepo`クラスを以下のように実装します。このクラスは、物件情報が記載されたディクショナリを初期化時にロードします。

```py:rentomatic/repository/memrepo.py
from rentomatic.domain.room import Room
from rentomatic.repository.iroomrepo import IRoomRepo


class MemRepo(IRoomRepo):
    def __init__(self, data: list[dict]):
        self.data = data

    def list(self):
        return [Room.from_dict(i) for i in self.data]

    def add(self, room):
        self.data.append(room)
        return 0
```

リポジトリの実体には、ストレージシステム固有の処理を記載できます。`MemRepo`では、Python のディクショナリとリストに関する操作を記載しています。

一方で、リポジトリの外側の層、つまりリポジトリを利用するユースケース側では、ストレージシステム固有の処理を機にする必要がありません。`MemRepo`を初期化して`list()`を呼べば、`Room`のリストを取得できます。

## リポジトリのテスト

単体テストを記載しやすいこともクリーンアーキテクチャの特徴です。ここで`MemRepo`のテストを書きます。（書籍ではテスト駆動開発で実装しているため、実際には先にテストを書いています）

```py:tests/repository/test_memrepo.py
import pytest

from rentomatic.domain.room import Room
from rentomatic.repository.memrepo import MemRepo


@pytest.fixture
def room_dicts():
    return [
        {
            "code": "f853578c-fc0f-4e65-81b8-566c5dffa35a",
            "size": 215,
            "price": 39,
            "longitude": -0.09998975,
            "latitude": 51.75436293,
        },
# 省略
    ]


def test_repository_list_without_parameters(room_dicts):
    repo = MemRepo(room_dicts)

    rooms = [Room.from_dict(i) for i in room_dicts]

    assert repo.list() == rooms


def test_repository_add(room_dicts):
    repo = MemRepo(room_dicts[0:3])

    rooms = [Room.from_dict(i) for i in room_dicts]
    repo.add(room_dicts[3])

    assert repo.list() == rooms
```

これで`MemRepo`が正しく動作することが確認できました。

# ユースケース

ユースケースには、アプリで実行する実際のビジネスロジックを記載します。このアプリの場合、物件情報を検索・登録・更新・削除するような処理が該当します。

ここでは、すべての物件を取得するユースケースと、所有する物件の賃料の合計を取得するユースケースを関数として作成します。（書籍では前者のみ実装しています。）

各ユースケースでは、リポジトリに実装されている`list()`メソッドを利用して`Room`の一覧を取得します。ユースケースの実装が、リポジトリが利用するデータストレージに依存していないことがポイントです。

```py:rentomatic/use_cases/room_list.py
from rentomatic.domain.room import Room
from rentomatic.repository.iroomrepo import IRoomRepo


def room_list_use_case(repo: IRoomRepo) -> list[Room]:
    """Get list of all Rooms"""
    return repo.list()


def room_price_all_use_case(repo: IRoomRepo) -> int:
    """Get sum of all room prices"""
    total = 0
    rooms = repo.list()

    for r in rooms:
        total += r.price
    return total

```

なお、各ユースケースにおいて、抽象クラスで型ヒントをつけることで、リポジトリに未実装のメソッドを利用することを防止しています。（[こちらの記事](https://qiita.com/bee2/items/73529b18cf06b92e83bf#%E6%8A%BD%E8%B1%A1%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%92%E5%9E%8B%E3%82%A2%E3%83%8E%E3%83%86%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3)を参考にしました。）

## ユースケースのテスト

リポジトリの場合と同様に、ユースケースも単体テストを記載します。

ここではリポジトリはモックでテストしていることに注目してください。例えばリポジトリにデータベースを利用している場合でも、ユースケースのテストではデータベースを用意する必要がありません。アーキテクチャの外側にある外部システムに依存しないことのメリットですね。

```py:tests/use_cases/test_room_list.py
import uuid
from unittest import mock

import pytest

from rentomatic.domain.room import Room
from rentomatic.use_cases.room_list import room_list_use_case, room_price_all_use_case


@pytest.fixture
def domain_rooms():
    room_1 = Room(
        code=uuid.uuid4(),
        size=215,
        price=39,
        longitude=-0.09998975,
        latitude=51.75436293,
    )
# 省略
    return [room_1, room_2, room_3, room_4]


def test_room_list_without_parameters(domain_rooms):
    repo = mock.Mock()
    repo.list.return_value = domain_rooms

    result = room_list_use_case(repo)

    repo.list.assert_called_with()
    assert result == domain_rooms


def test_room_price_all(domain_rooms):
    repo = mock.Mock()
    repo.list.return_value = domain_rooms

    result = room_price_all_use_case(repo)

    repo.list.assert_called_with()
    assert result == 213
```

# アプリケーション(CLI)

最後に、ユーザーがアプリを実際に利用するためのインターフェースを実装します。まずは最も簡単なインターフェースとしてコマンドラインツールを作成します。

このツールは、リポジトリに 4 件の物件情報をロードして初期化し、ユースケースを実行して物件情報を全件取得します。

```py:cli.py
#!/usr/bin/env python

from rentomatic.repository.memrepo import MemRepo
from rentomatic.use_cases.room_list import room_list_use_case

rooms = [
    {
        "code": "f853578c-fc0f-4e65-81b8-566c5dffa35a",
        "size": 215,
        "price": 39,
        "longitude": -0.09998975,
        "latitude": 51.75436293,
    },
# 省略 合計4件の物件情報を定義
]

repo = MemRepo(rooms)
result = room_list_use_case(repo)

print([room.to_dict() for room in result])
```

このツールを実行すると、すべての物件情報を取得できます。

```sh
❯ poetry run python ./cli.py
[{'code': 'f853578c-fc0f-4e65-81b8-566c5dffa35a', 'size': 215, 'price': 39, 'longitude': -0.09998975, 'latitude': 51.75436293}, {'code': 'fe2c3195-aeff-487a-a08f-e0bdc0ec6e9a', 'size': 405, 'price': 66, 'longitude': 0.18228006, 'latitude': 51.74640997}, {'code': '913694c6-435a-4366-ba0d-da5334a611b2', 'size': 56, 'price': 60, 'longitude': 0.27891577, 'latitude': 51.45994069}, {'code': 'eed76e77-55c1-41ce-985d-ca49bf6c0585', 'size': 93, 'price': 48, 'longitude': 0.33894476, 'latitude': 51.39916678}]
```

このスクリプトで重要な部分は、以下の 2 行です。リポジトリを初期化し、それをユースケース渡してビジネスロジックを実行し、結果を取得するという一連の処置を実行しています。

```py
repo = MemRepo(rooms)
result = room_list_use_case(repo)
```

これでクリーンアーキテクチャのコアとなる機能を実装できました。この後の章では、このアプリに変更を加えることで、クリーンアーキテクチャの利点を検証していきます。

---

# クリーンアーキテクチャの利点

## テストコードを記述しやすい

## アプリケーションを変更可能

## リポジトリを変更可能

# おわりに
